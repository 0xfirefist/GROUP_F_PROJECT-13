"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
class IOSExtensionsService {
    constructor($fs, $pbxprojDomXcode, $xcode) {
        this.$fs = $fs;
        this.$pbxprojDomXcode = $pbxprojDomXcode;
        this.$xcode = $xcode;
    }
    addExtensionsFromPath({ extensionsFolderPath, projectData, platformData, pbxProjPath }) {
        return __awaiter(this, void 0, void 0, function* () {
            const targetUuids = [];
            let addedExtensions = false;
            if (!this.$fs.exists(extensionsFolderPath)) {
                return false;
            }
            const project = new this.$xcode.project(pbxProjPath);
            project.parseSync();
            this.$fs.readDirectory(extensionsFolderPath)
                .filter(fileName => {
                const filePath = path.join(extensionsFolderPath, fileName);
                const stats = this.$fs.getFsStats(filePath);
                return stats.isDirectory() && !fileName.startsWith(".");
            })
                .forEach(extensionFolder => {
                const targetUuid = this.addExtensionToProject(extensionsFolderPath, extensionFolder, project, projectData, platformData);
                targetUuids.push(targetUuid);
                addedExtensions = true;
            });
            this.$fs.writeFile(pbxProjPath, project.writeSync({ omitEmptyValues: true }));
            this.prepareExtensionSigning(targetUuids, projectData, pbxProjPath);
            return addedExtensions;
        });
    }
    addExtensionToProject(extensionsFolderPath, extensionFolder, project, projectData, platformData) {
        const extensionPath = path.join(extensionsFolderPath, extensionFolder);
        const extensionRelativePath = path.relative(platformData.projectRoot, extensionPath);
        const files = this.$fs.readDirectory(extensionPath)
            .filter(filePath => !filePath.startsWith("."))
            .map(filePath => path.join(extensionPath, filePath));
        const target = project.addTarget(extensionFolder, 'app_extension', extensionRelativePath);
        project.addBuildPhase([], 'PBXSourcesBuildPhase', 'Sources', target.uuid);
        project.addBuildPhase([], 'PBXResourcesBuildPhase', 'Resources', target.uuid);
        project.addBuildPhase([], 'PBXFrameworksBuildPhase', 'Frameworks', target.uuid);
        const extJsonPath = path.join(extensionsFolderPath, extensionFolder, "extension.json");
        if (this.$fs.exists(extJsonPath)) {
            const extensionJson = this.$fs.readJson(extJsonPath);
            _.forEach(extensionJson.frameworks, framework => {
                project.addFramework(framework, { target: target.uuid });
            });
            if (extensionJson.assetcatalogCompilerAppiconName) {
                project.addToBuildSettings("ASSETCATALOG_COMPILER_APPICON_NAME", extensionJson.assetcatalogCompilerAppiconName, target.uuid);
            }
        }
        project.addPbxGroup(files, extensionFolder, extensionPath, null, { isMain: true, target: target.uuid, filesRelativeToProject: true });
        project.addBuildProperty("PRODUCT_BUNDLE_IDENTIFIER", `${projectData.projectIdentifiers.ios}.${extensionFolder}`, "Debug", extensionFolder);
        project.addBuildProperty("PRODUCT_BUNDLE_IDENTIFIER", `${projectData.projectIdentifiers.ios}.${extensionFolder}`, "Release", extensionFolder);
        project.addToHeaderSearchPaths(extensionPath, target.pbxNativeTarget.productName);
        return target.uuid;
    }
    prepareExtensionSigning(targetUuids, projectData, projectPath) {
        const xcode = this.$pbxprojDomXcode.Xcode.open(projectPath);
        const signing = xcode.getSigning(projectData.projectName);
        if (signing !== undefined) {
            _.forEach(targetUuids, targetUuid => {
                if (signing.style === "Automatic") {
                    xcode.setAutomaticSigningStyleByTargetKey(targetUuid, signing.team);
                }
                else {
                    for (const config in signing.configurations) {
                        const signingConfiguration = signing.configurations[config];
                        xcode.setManualSigningStyleByTargetKey(targetUuid, signingConfiguration);
                        break;
                    }
                }
            });
        }
        xcode.save();
    }
    removeExtensions({ pbxProjPath }) {
        const project = new this.$xcode.project(pbxProjPath);
        project.parseSync();
        project.removeTargetsByProductType("com.apple.product-type.app-extension");
        this.$fs.writeFile(pbxProjPath, project.writeSync({ omitEmptyValues: true }));
    }
}
exports.IOSExtensionsService = IOSExtensionsService;
$injector.register("iOSExtensionsService", IOSExtensionsService);
